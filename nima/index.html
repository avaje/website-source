<html>

<head>
  <meta name="layout" content="_layout/base-nima.html" />
  <meta name="bread1" content="nima" href="/nima/" />
  <#assign index="active">
</head>

<body>
  <h1 id="overview">
    <span class="logo">Avaje</span>&thinsp;Nima
  </h1>

  <table style="width: 100%;">
    <tr>
      <th>Discord</th>
      <th>Source</th>
      <th>API Docs</th>
      <th>Issues</th>
      <th>Releases</th>
    </tr>
    <tr>
      <td><a href="https://discord.gg/Qcqf9R27BR">Discord</td>
      <td><a target="_blank" href="https://github.com/avaje/avaje-nima">GitHub</a></td>
      <td><a target="_blank"
          href="https://javadoc.io/doc/io.avaje/avaje-nima/latest/io.avaje.nima/io/avaje/nima/package-summary.html">Javadoc</a>
      </td>
      <td><a target="_blank" href="https://github.com/avaje/avaje-nima/issues">GitHub</a></td>
      <td><a href="https://github.com/avaje/avaje-nima/releases"><img
            src="https://img.shields.io/maven-central/v/io.avaje/avaje-nima.svg?label=Maven%20Central"></a></td>
    </tr>
  </table>

  <p><br><br>
    avaje-nima is a combination of Helidon SE Webserver and Avaje libraries, including:
  </p>
  <ul>
    <li><a href="https://helidon.io/#se">Helidon SE</a> - High performance webserver</li>
    <li><a href="/inject/">avaje-inject</a> - Dependency injection</li>
    <li><a href="/http/">avaje-http</a> - JAX-RS style controller generation</li>
    <li><a href="/jsonb/">avaje-jsonb</a> - JSON adapter generation</li>
    <li><a href="/validator/">avaje-validator</a> - Bean validation</li>
    <li><a href="/config/">avaje-config</a> - External configuration</li>
  </ul>
  <p>
    Avaje Nima uses annotation processors to generate the necessary code at compile time
    to wire up controllers, dependency injection, JSON adapters and validation.
    This results in a very lightweight runtime with minimal dependencies and no reflection,
    making it well suited for GraalVM native image applications.
  </p>

  <span id="start"></span>

  <h2 id="dependencies">Dependencies</h2>
  <h4>1. Add <em>avaje-nima</em> dependencies</h4>
  <p>
    <a href="https://github.com/avaje/avaje-nima/releases">
      <img src="https://img.shields.io/maven-central/v/io.avaje/avaje-nima.svg?label=avaje.nima.version"></a>
  </p>

  <pre content="xml">
    <dependency>
      <groupId>io.avaje</groupId>
      <artifactId>avaje-nima</artifactId>
      <version>${avaje.nima.version}</version>
    </dependency>

    <!-- test dependency -->
    <dependency>
      <groupId>io.avaje</groupId>
      <artifactId>avaje-nima-test</artifactId>
      <version>${avaje.nima.version}</version>
      <scope>test</scope>
    </dependency>
  </pre>

  <h2 id="annotation-processor">Annotation processor</h2>
  <h4>2. Add the annotation processor</h4>
  <p>
    <code>avaje-nima-generator</code> is a composite of:
  </p>
  <ul>
    <li>avaje-http-helidon-generator - for the route adapter</li>
    <li>avaje-inject-generator - for dependency injection</li>
    <li>avaje-jsonb-generator - for json adapters</li>
    <li>avaje-validator-generator - for bean validation</li>
    <li>avaje-record-builder - for record builders</li>
    <li>avaje-spi-service - for automatic service generation</li>
    <li>jstachio-apt - for mustache template rendering</li>
    <li>avaje-http-client-generator - for test client generation</li>
  </ul>

  <pre content="xml">
    <!-- Annotation processors -->
    <dependency>
      <groupId>io.avaje</groupId>
      <artifactId>avaje-nima-generator</artifactId>
      <version>${avaje.nima.version}</version>
      <scope>provided</scope>
      <optional>true</optional>
    </dependency>
  </pre>

  <h4>2a. JDK 23+</h4>
  <p>
    In JDK 23+, annotation processors added as a provided dependency are disabled by default,
    so we need to add a compiler property to re-enable via:
  </p>
  <pre content="xml">
    <properties>
      <maven.compiler.proc>full</maven.compiler.proc>
    </properties>
  </pre>

  <h2 id="first-controller">Controller</h2>
  <p>
    Create a controller and annotate it with http-api annotations.
  </p>

  <pre content="java">
    package org.example.web;

    import io.avaje.http.api.*;
    import io.avaje.inject.*;
    import io.avaje.jsonb.Json;

    @Controller
    public class HelloController {

      @Produces("text/plain")
      @Get("/")
      String hello() {
        return "hello world";
      }

      @Get("/json")
      HelloBean helloJson() {
        return new HelloBean(97, "Hello JSON");
      }

      @Json
      public record HelloBean(int id, String name) {
      }
    }
  </pre>


  <h2 id="main"><em>Nima</em> Class</h2>
  <p>
    The <em>Nima</em> class will start a <em>BeanScope</em>, register generated controller routes, and start the helidon webserver.
    <br/><br/>
    The <em>Nima</em> class will search your <em>BeanScope</em> for a <em>WebServerConfig.Builder</em>, if you provide one in your
    <em>BeanScope</em> it will be used to configure the webserver.
  </p>
  <pre content="java">
    package org.example;

    import io.avaje.nima.Nima;

    public class Main {

      public static void main(String[] args) {

        var webServer = Nima.builder()
          .port(8080)
          .build();

        webServer.start();
      }
    }
  </pre>
  <p>
    Now you can run the application main method,
  </p>
  <pre content="sh">
21:23:37.951 [main] INFO  io.avaje.inject - Wired beans in 77ms
21:23:38.001 [features-thread] INFO  i.h.common.features.HelidonFeatures - Helidon SE 4.2.2 features: [Config, Encoding, Media, Metrics, Registry, WebServer]
21:23:38.005 [start @default (/0.0.0.0:8080)] INFO  io.helidon.webserver.ServerListener - [0x2132b530] http://0.0.0.0:8080 bound for socket '@default'
21:23:38.008 [main] INFO  io.helidon.webserver.LoomServer - Started all channels in 6 milliseconds. 369 milliseconds since JVM startup. Java 21.0.5+9-LTS-239
  </pre>
  <p>
    ... and perform a quick test using curl.
  </p>
  <pre content="sh">
    curl http://localhost:8080
    hello world

    curl http://localhost:8080/json
    {"id":97,"name":"Hello JSON"}
  </pre>

  <h4>Generated code</h4>
  <p>
    After compiling, we should see in <code>target/generated-sources/annotations</code>:
  </p>
  <ul>
    <li><code>HelloController$DI</code> - which performs the dependency injection wiring of the controller</li>
    <li><code>HelloController$Route</code> - which registers the controller routes with Helidon and adapts the
      Helidon request and response to the controller code</li>
    <li><code>HelloController$Route$DI</code> - the dependency injection for the routes</li>
    <li><code>HelloController$HelloBeanJsonAdapter</code> - the JSON adapter for HelloBean</li>
  </ul>

  <h4>Generated test code</h4>
  <p>
    In <code>target/generated-test-sources/test-annotations</code>
    useful testing classes are generated for us:
  </p>
  <ul>
    <li><code>HelloControllerTestAPI</code> - a test client inteface to test the controller</li>
    <li><code>HelloControllerTestAPIHttpClient</code> - the test client implementation</li>
  </ul>

  <#include "/_http/controllers.ftl">
  <#include "/_http/path.ftl">
  <#include "/_http/beanparam.ftl">
  <#include "/_http/post.ftl">
  <#include "/_http/header.ftl">

  <h2 id="testing">Testing Controllers</h2>
  <p>
    <code>avaje-nima-test</code> provides support for testing controllers which includes:
  </p>
  <ul>
    <li>Generating test clients for each controller</li>
    <li>Injecting Http Clients and Webserver into tests</li>
    <li>Starting webserver on a random port for any test with an injected Http Client</li>
  </ul>

  <h3>Test Injection</h3>
  <p>
    <code>avaje-nima-test</code> can inject dependencies into a test including
    Http Clients and the Helidon Webserver.
  </p>
  <ul>
    <li><code>io.avaje.http.client.HttpClient</code></li>
    <li><code>io.avaje.http.client.HttpClient.Builder</code></li>
    <li>A type annotated with <code>io.avaje.http.api.@Client</code> or <code>io.avaje.http.api.@Path</code></li>
  </ul>
  <p>
    When a test includes any of the above Http Client types to be injected,
    <code>avaje-nima-test</code> will automatically start a Helidon webserver
    on a random port for the test to use, and inject the Http Client(s) configured
    into the test (with the correct port to connect to the started webserver).
  </p>

  <h3 id="inject-webserver"><span>@Inject WebServer</span></h3>
  <p>
    We typically don't need to inject the <code>WebServer</code> unless we want to
    check the port or stop/start the server manually.
  </p>

  <details>
    <summary><code>example: @Inject WebServer</code></summary>
    <pre content="java">
      package org.example.web;

      import io.avaje.http.client.HttpClient;
      import io.avaje.inject.test.InjectTest;
      import io.helidon.webserver.WebServer;
      import jakarta.inject.Inject;
      import org.junit.jupiter.api.Test;
      import static org.assertj.core.api.Assertions.assertThat;

      @InjectTest
      class MyControllerTest {

        @Inject WebServer webServer;
        @Inject HttpClient httpClient;

        @Test
        void testSomething() {

          // webserver started on random port
          assertThat(webServer.port()).isNotEqualTo(0);

          // perform test using httpClient
          HttpResponse<|String> res = httpClient.request().GET().asString();
          assertThat(res.statusCode()).isEqualTo(200);
          assertThat(res.body()).isEqualTo("hello world");
        }
      }
    </pre>
  </details>

  <h3 id="inject-httpclient"><span>@Inject HttpClient</span></h3>
  <p>
    We can inject the <code>HttpClient</code> to perform requests against the started webserver.
  </p>
  <details>
    <summary><code>example: @Inject HttpClient</code></summary>
    <pre content="java">
      package org.example.web;

      import io.avaje.http.client.HttpClient;
      import io.avaje.inject.test.InjectTest;
      import io.helidon.webserver.WebServer;
      import jakarta.inject.Inject;
      import org.junit.jupiter.api.Test;
      import static org.assertj.core.api.Assertions.assertThat;

      @InjectTest
      class MyControllerTest {

        @Inject HttpClient httpClient;

        @Test
        void testSomething() {

          // perform test using httpClient
          HttpResponse<|String> res = httpClient.request().GET().asString();
          assertThat(res.statusCode()).isEqualTo(200);
          assertThat(res.body()).isEqualTo("hello world");
        }
      }
    </pre>
  </details>

  <h3 id="inject-httpclient-builder"><span>@Inject HttpClient.Builder</span></h3>
  <p>
    We can inject the <code>HttpClient.Builder</code> to perform requests against the started webserver.
    With the Builder we can customise the HttpClient as needed including things like setting the
    interceptors (that might automatically set http headers etc).
  </p>

  <details>
    <summary><code>example: @Inject HttpClient</code></summary>
    <p>
      For example lets say that we have a filter that requires a "Caller-Id" header to be set on each request,
      and we have a test configuration that sets a default Caller-Id for tests like:
    </p>
    <pre content="java">
      @TestScope
      @Factory
      class TestConfiguration {

          /** Test clients by default will use this interceptor. */
          @Bean
          HttpClient.Builder httpClientBuilder() {
              return HttpClient.builder()
                  .requestIntercept(new RequestIntercept() {
                      @Override
                      public void beforeRequest(HttpClientRequest request) {
                          request.header("eroad-callerid", "local-test");
                      }
                  });
          }
      }
    </pre>
    <p>
      We can inject the HttpClient.Builder so that we can change the interceptor for a specific test.
    </p>
    <pre content="java">
      package org.example.web;

      import io.avaje.http.client.HttpClient;
      import io.avaje.inject.test.InjectTest;
      import io.helidon.webserver.WebServer;
      import jakarta.inject.Inject;
      import org.junit.jupiter.api.Test;
      import static org.assertj.core.api.Assertions.assertThat;

      @InjectTest
      class MyControllerTest {

        @Inject HttpClient.Builder httpClientBuilder;

        @Test
        void testSomething() {

          // create a custom http client for this test
          HttpClient httpClient = httpClientBuilder
            .requestIntercept(request -> request.header("eroad-callerid", "special-test"))
            .build();

          // perform test using httpClient
          HttpResponse<|String> res = httpClient.request().GET().asString();
          assertThat(res.statusCode()).isEqualTo(200);
          assertThat(res.body()).isEqualTo("hello world");
        }
      }
    </pre>
  </details>

  <h3 id="inject-generated-client"><span>@Inject generated client</span></h3>
  <p>
    Given we have a <code>@Controller</code> called <code>HelloController</code> then there will
    automatically be a generated test client called <code>HelloControllerTestAPI</code> and we
    can inject that into our test. This allows us to use a type safe client to perform requests.
  </p>
  <details>
    <summary><code>example: @Inject generated client</code></summary>
    <pre content="java">
      package org.example.web;

      import io.avaje.http.client.HttpClient;
      import io.avaje.inject.test.InjectTest;
      import io.helidon.webserver.WebServer;
      import jakarta.inject.Inject;
      import org.junit.jupiter.api.Test;
      import static org.assertj.core.api.Assertions.assertThat;

      @InjectTest
      class MyControllerTest {

        @Inject HelloControllerTestAPI myClient;

        @Test
        void testUsingGeneratedClient() {

          // perform test using generated client API
          HttpResponse<|String> response = myClient.hello();
          assertThat(response.statusCode()).isEqualTo(200);
          assertThat(response.body()).isEqualTo("hello world");

          HttpResponse<|HelloBean> response = myClient.helloJson();
          assertThat(response.statusCode()).isEqualTo(200);

          HelloBean body = response.body();
          assertThat(body.id()).isEqualTo(97);
          assertThat(body.name()).isEqualTo("Hello JSON");
        }
      }
    </pre>
  </details>


  <h2 id="error-handlers">Error handlers</h2>
  <p>
    Commonly exception handling is done in a dedicated exception handling class.
    This can be done by creating a controller that has <code>@ExceptionHandler</code> methods.
  </p>
  <p>
    The handler method:
  </p>
  <ul>
    <li>Takes an Exception type</li>
    <li>Optionally take a <code>ServerRequest</code></li>
    <li>Optionally take a <code>ServerResponse</code></li>
  </ul>
  <p>
    In terms of return type / error response body, the handler method can either:
  </p>
  <ul>
    <li>Return void, meaning the response should be explicitly set to the ServerResponse</li>
    <li>Return String, where the response is a <code>text/plain</code></li>
    <li>Return another type which is deemed a <code>@Json</code> Bean</li>
  </ul>

  <pre content="java">
    @Controller
    final class ErrorHandlers {

      @Produces(statusCode = ...)
      @ExceptionHandler
      SomeErrorResponse handler(SomeException ex, ServerRequest req, ServerResponse res) {
        ...
      }

    }
  </pre>

  <h3 id="error-example">Example error controller</h3>
  <pre content="java">
    package org.example.web;

    import io.avaje.http.api.Controller;
    import io.avaje.http.api.ExceptionHandler;
    import io.avaje.http.api.Produces;
    import io.helidon.http.BadRequestException;
    import io.helidon.webserver.http.ServerRequest;
    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;

    import java.util.UUID;

    @Controller
    final class ErrorHandlers {

      private static final Logger log = LoggerFactory.getLogger(ErrorHandlers.class);

      @Produces(statusCode = 500)
      @ExceptionHandler
      ErrorResponse defaultError(Exception ex, ServerRequest req) {
        var path = path(req);
        var traceId = log(ex, path);
        return ErrorResponse.builder()
          .statusCode(500)
          .path(path)
          .traceId(traceId)
          .message("Unhandled server error")
          .build();
      }

      @Produces(statusCode = 400)
      @ExceptionHandler
      ErrorResponse badRequest(BadRequestException ex, ServerRequest req) {
        var path = path(req);
        var traceId = log(ex, path);
        return ErrorResponse.builder()
          .statusCode(400)
          .path(path)
          .traceId(traceId)
          .message("Unhandled server error")
          .build();
      }

      private static String path(ServerRequest req) {
        return req != null && req.path() != null ? req.path().path() : null;
      }

      private static UUID log(Throwable ex, String path) {
        UUID traceId = UUID.randomUUID();
        log.error("Unhandled server error path:{} trace:{}", path, traceId, ex);
        return traceId;
      }

    }
  </pre>
  <p>
    With the above example the error response has a JSON payload. The code for the
    <code>ErrorResponse</code> is:
  </p>
  <pre content="java">
    import io.avaje.jsonb.Json;
    import io.avaje.recordbuilder.RecordBuilder;

    import java.util.UUID;

    @Json
    @RecordBuilder
    public record ErrorResponse(
      int statusCode,
      String path,
      UUID traceId,
      String message) {

      public static ErrorResponseBuilder builder() {
        return ErrorResponseBuilder.builder();
      }
    }
  </pre>
  <details>
    <summary>Generated Code: (click to expand) </summary>
    <pre content="java">
      @Generated("avaje-helidon-generator")
      @Component
      public final class ErrorHandlers$Route implements HttpFeature {

        private final ErrorHandlers controller;
        private final JsonType<|ErrorResponse> errorResponseJsonType;

        public ErrorHandlers$Route(ErrorHandlers controller, Jsonb jsonb) {
          this.controller = controller;
          this.errorResponseJsonType = jsonb.type(ErrorResponse.class);
        }

        @Override
        public void setup(HttpRouting.Builder routing) {
          routing.error(Exception.class, this::_defaultError);
          routing.error(BadRequestException.class, this::_badRequest);
        }

        private void _defaultError(ServerRequest req, ServerResponse res, Exception ex) {
          res.status(INTERNAL_SERVER_ERROR_500);
          var result = controller.defaultError(ex, req);
          if (result == null) {
            res.status(NO_CONTENT_204).send();
          } else {
            res.headers().contentType(MediaTypes.APPLICATION_JSON);
            errorResponseJsonType.toJson(result, JsonOutput.of(res));
          }
        }

        private void _badRequest(ServerRequest req, ServerResponse res, BadRequestException ex) {
          res.status(BAD_REQUEST_400);
          var result = controller.badRequest(ex, req);
          if (result == null) {
            res.status(NO_CONTENT_204).send();
          } else {
            res.headers().contentType(MediaTypes.APPLICATION_JSON);
            errorResponseJsonType.toJson(result, JsonOutput.of(res));
          }
        }

      }
    </pre>
  </details>

  <h3 id="error-testing">Testing error handlers</h3>
  <p>
    We can test error handlers by injecting a test double that will invoke the error.
  </p>
  <p>
    With the test below, we use a test double for the <code>HelloController</code>
    that simulates a failure when the <code>hello()</code> method is called.
    This will cause the <code>defaultError(Exception, ServerRequest)</code> method
    in the <code>ErrorHandlers</code> controller to be invoked.
  </p>

  <pre content="java">

    @InjectTest
    class HelloControllerErrorTest {

        @Inject HelloControllerTestAPI api;

        // use test double in place of the real HelloController used by the server
        @Mock HelloController failingController = Mockito.mock(HelloController.class);


        @Test
        void testHelloError_expect500() {
            // simulate failure in the service method
            when(failingController.hello()).thenThrow(new RuntimeException("Simulated failure"));
            try {
                api.hiMaybeError();
                fail("Should have thrown HttpException...");

            } catch (HttpException e) {
                // error response status code 500
                assertThat(e.statusCode()).isEqualTo(500);

                // if we know the error response body type we can convert to that
                ErrorResponse errorResponse = e.bean(ErrorResponse.class);
                assertThat(errorResponse.path()).isEqualTo("/hello");

                // or just get the error body contents
                String errorBodyContent = e.bodyAsString();
                assertThat(errorBodyContent).contains("...");
            }
        }
    }
  </pre>


  <h2 id="filters">Filters</h2>
  <p>
    To add a Filter we can add a controller that has a <code>@Filter</code> method
    that takes a <code>FilterChain</code>, <code>RoutingRequest</code> and
    optionally a <code>RoutingResponse</code>.
  </p>
  <pre content="java">

    @Controller
    final class MyFilter {

      @Filter
      void filter(FilterChain chain, RoutingRequest req) {
        ...
      }

    }
  </pre>

  <h3 id="filter-example">Example filter</h3>
  <p>
    The following is an example filter that reads a "Caller-Id" request header and rejects the
    request if one isn't provided.
  </p>
  <pre content="java">
    import io.avaje.http.api.Controller;
    import io.avaje.http.api.Filter;
    import io.helidon.http.BadRequestException;
    import io.helidon.http.HeaderName;
    import io.helidon.http.HeaderNames;
    import io.helidon.webserver.http.FilterChain;
    import io.helidon.webserver.http.RoutingRequest;
    import io.helidon.webserver.http.ServerRequest;

    import java.util.Optional;
    import java.util.Set;

    @Controller
    final class CallerIdFilter {

      private static final HeaderName CALLER_ID = HeaderNames.create("Caller-Id");

      private static final Set<|String> BYPASS = Set.of("/ping");

      @Filter
      void filter(FilterChain chain, RoutingRequest req) {
        var path = path(req);
        if (BYPASS.contains(path)) {
          chain.proceed();
        } else {
          String callerId = callerId(req).orElseThrow(() -> new BadRequestException("Caller-Id required"));
          handleCallerMetrics(path, callerId);
          chain.proceed();
        }
      }

      private void handleCallerMetrics(String path, String callerId) {
        // capture metrics
      }

      private Optional<|String> callerId(RoutingRequest request) {
        return request.headers().first(CALLER_ID);
      }


      private static String path(ServerRequest req) {
        return req != null && req.path() != null ? req.path().path() : null;
      }

    }
  </pre>

  <h2 id="graalvm">GraalVM native image</h2>
  <p>
    We can build GraalVM native images with Avaje Nima and the associated dependencies
    including Helidon SE webserver.
  </p>
  <p>
    The maven profile below builds a native executable and then builds a docker image
    for that native executable using a UBI micro base image with glibc.
  </p>
  <ul>
    <li><code>native-maven-plugin</code>: builds the native executable</li>
    <li><code>jib-maven-plugin</code>: builds a docker image including the native executable</li>
  </ul>

  <h4>maven profile - native image build</h4>
  <pre content="xml">

      <profile>
        <id>native</id>
        <build>
          <plugins>
            <plugin> <!-- build native executable -->
              <groupId>org.graalvm.buildtools</groupId>
              <artifactId>native-maven-plugin</artifactId>
              <version>0.11.3</version>
              <extensions>true</extensions>
              <executions>
                <execution>
                  <id>build-native</id>
                  <goals>
                    <goal>compile-no-fork</goal>
                  </goals>
                  <phase>package</phase>
                  <configuration>
                    <mainClass>org.example.Main</mainClass>
                  </configuration>
                </execution>
              </executions>
              <configuration>
                <buildArgs>
                  <buildArg>--gc=G1</buildArg>
                  <buildArg>-R:MaxGCPauseMillis=50</buildArg>
                  <buildArg>-R:MaxHeapSize=400m</buildArg>
                  <buildArg>--emit build-report</buildArg>
                  <buildArg>--no-fallback</buildArg>
                  <buildArg>-march=compatibility</buildArg>
                  <buildArg>--allow-incomplete-classpath</buildArg>
                  <buildArg>--static-nolibc</buildArg>
                </buildArgs>
              </configuration>
            </plugin>

            <plugin> <!-- build docker image for native executable -->
              <groupId>com.google.cloud.tools</groupId>
              <artifactId>jib-maven-plugin</artifactId>
              <version>3.4.6</version>
              <executions>
                <execution>
                  <goals>
                    <goal>dockerBuild</goal>
                  </goals>
                  <phase>package</phase>
                </execution>
              </executions>
              <dependencies>
                <dependency>
                  <groupId>com.google.cloud.tools</groupId>
                  <artifactId>jib-native-image-extension-maven</artifactId>
                  <version>0.1.0</version>
                </dependency>
              </dependencies>

              <configuration>
                <pluginExtensions>
                  <pluginExtension>
                    <implementation>
                      com.google.cloud.tools.jib.maven.extension.nativeimage.JibNativeImageExtension
                    </implementation>
                    <properties> <!-- name of executable produced -->
                      <imageName>my-service</imageName>
                    </properties>
                  </pluginExtension>
                </pluginExtensions>
                <container>
                  <mainClass>org.example.Main</mainClass>
                  <ports>8080</ports>
                </container>
                <from> <!-- UBI micro base image with glibc -->
                  <image>redhat/ubi10-micro:10.1-1762215812</image>
                </from>
                <to>
                  <image>${project.artifactId}-native:${project.version}</image>
                </to>
              </configuration>
            </plugin>
          </plugins>
        </build>
      </profile>

  </pre>

  <h4>MacOS specific profile</h4>
  <p>
    MacOS does not support G1 garbage collector in native images, so we need to
    create a specific profile for MacOS builds that omits the G1 related build args.
  </p>
  <pre content="xml">
      <profile>
        <id>mac</id>
        <activation>
          <os>
            <family>mac</family>
          </os>
        </activation>
        <build>
          <plugins>
            <plugin> <!-- native build on MacOS -->
              <groupId>org.graalvm.buildtools</groupId>
              <artifactId>native-maven-plugin</artifactId>
              <configuration>
                <buildArgs> <!-- No G1 on MacOS native image -->
                  <buildArg>-R:MaxHeapSize=400m</buildArg>
                  <buildArg>--emit build-report</buildArg>
                  <buildArg>--no-fallback</buildArg>
                  <buildArg>-march=compatibility</buildArg>
                  <buildArg>--static-nolibc</buildArg>
                </buildArgs>
              </configuration>
            </plugin>
          </plugins>
        </build>
      </profile>
  </pre>


  <p><br><br><br><br><br><br></p>
</body>

</html>
